# Creating a Software Solution [P6] [D2]

## Analysis

### Questionnaires, Surveys and Market Analysis

Before designing or building a piece of software it is important that the developers are aware of the problem they are building a solution to and understand what they must do in order to provide a successful product. One way to understand the market of the product better is to distribute questionnaires and surveys via the internet or in person. By asking the people that the product will be built for what exactly they want, efforts can be much more accurately targeted. Using social media websites such as Twitter and Facebook, and by asking for support from organisations that the target market would likely follow on such websites, a development team can quickly gauge what parts of a solution are most important to the users, and how they can build a product that will cover those aspects correctly.

Developers can also look to other similar projects and products for ways in which to improve. By looking at popular solutions' help forum, issue tracking and discussion websites, the features most often missed from a piece of software can be quickly determined. If users often feel the need for a tool that isn't available in their current software packages, a new product that has this tool can easily gain attention.

As we had been tasked to create the popular card game Blackjack in a programming language of our choice &ndash; I chose Python &ndash; I looked online for previously-build versions of the game, in the hopes of identifying common errors in such programs. I found that when dealing cards, many programs would generate a random integer between one and eleven, inclusive. This is because royal cards in Blackjack all count as ten points and an ace as either one or eleven points. In order to accurately emulate a real game of Blackjack, however, one must generate a random integer with a maximum value of thirteen. This will give every card the correct probability of being dealt, which has a very significant effect on the game's outcome.

### Requirements

During and after the process of collecting information about the pitfalls of previous solutions and the wants of the target market, the development team will build a list of requirements. This list will be consulted throughout the project's life-cycle, in order that the programmers to not make the same mistakes others have made. The list of requirements will likely outline the defining attributes of the solution, as well as the more specific, new features that will set the program apart from its competition.

For my Blackjack program I created the following list of requirements:

* A "natural" win should be recognised; if the player or dealer score twenty-one points with their first hand, they should instantly be granted a victory.
* The game must allow the players, including the dealer, to twist three times. Once they have done this, they must be forced to stick.
* The program must pick cards in a fair way, giving equal probabilities to each of the cards in a suit. As Blackjack is almost exclusively played with a shoe of decks, the need to track individual cards is non-existent.
* The game should be simple to use, and provide and engaging user experience. This could be achieved by giving details about the cards being dealt, or by adding elements of story telling into the game.
* The game should allow the player to play again once a game has been completed. This is reminiscent of real Blackjack, in which gamblers would be encouraged to play again with the belief that they will fair better in next round.
* The program should keep track of the wins and losses of the dealer and player. This should ideally be preserved between instances of the program.
* Where possible (likely not on Windows) coloured text should be shown in the terminal. This can be used to quickly indicate to the player the outcome of a particular move.

## Design

### Data Flow

During the design stage of a software project, data flow diagram, of DFDs, are often created by the developers to plan the movement of information round the program during operation. Having this information in mind when designing the other aspects of the program can improve the efficiency of the final product, make development easier, and save the developers time that would otherwise be spend re-writing code. In order to better understand the flow of data around the Blackjack program, I designed the data flow diagram shown below.

<div class="i">
	<img src="/btec/img/06.3.1.svg">
	A DFD, or data flow diagram, showing how data may move around a Blackjack program.
	<ul>
		<li><strong>Blue</strong> &ndash; The main program runtime and the game function (<code>game()</code>).</li>
		<li><strong>Purple</strong> &ndash; The variables available throughout the application, such as the number of wins for the player and dealer.</li>
		<li><strong>Hot Pink</strong> &ndash; Input from the keyboard connected to the system, processed by the operating system and passed to the program.</li>
		<li><strong>Red</strong> &ndash; The output of the program, shown to the user in a command-line window. This may also be saved to a file or processed by another program, depending on implementation of the blackjack program.</li>
		<li><strong>Orange</strong> &ndash; The code called to send the logo banner as text to the output when the program launches.</li>
		<li><strong>Marigold</strong> &ndash; A function called by the main process to generate a random card.</li>
		<li><strong>Yellow</strong> &ndash; A function that is passed an array of known cards, before returning their value. If any of the cards are aces, the function will either ask the user to choose how many points to add, or decide for the AI based on the value of other variables.</li>
		<li><strong>Lime</strong> &ndash; A function that accepts an array of scores, and which then generates a score table using box-drawing characters and prints it to the output.</li>
		<li><strong>Green</strong> &ndash; A function used to add ANSI escape codes before and after a string of test. This is disabled if Windows is detected.</li>
	</ul>
	<div>Image by me; see <a href="/btec/license">license</a>.</div>
</div>

### Process Flow

As well as creating diagrams to show the flow of data around a program and between modules of a solution, developers often create diagrams to show the flow of the actual program. Using different shapes to represent different operations in a program, one can quickly prototype an element of a program. In a flow diagram, standardised shapes represent certain stages of a process:

* **Rounded rectangles** are used to signify the beginning and end of a process. In most flow diagrams there are only two, and there can only ever be one "start" shape. This is the first and last shape that an interpreter of the diagram will read, and cannot occur elsewhere in the process.

* **Rectangles** represent commands or sub-processes that must be undertaken during the execution of the main process. The accuracy and level of detail of these commands is something that can vary. Thanks to abstraction in programming, a large and potentially tedious part of a solution can be condensed into a single command. Addition detail about the process that must be completed at such a stage could be given in a separate diagram.

* **Parallelograms** are used to represent the commands and sub-processes that require with input or output. In the context of programming, this is most often interaction with the user, which could occur in the form of text, sound or possibly movement. This can be combined with a rhombus shape to perform a decision based on input, and the shape is often used to represent input and output in one stage.

* **Rhombi** are used to show decision-making. Often compared to the `if` statement found in almost all programming languages, a decision will typically have two outward routes, or potentially more. Decisions can appear in the form of a wide variety of questions, but most often only require a *yes* or *no* answer, simplifying the process of interpreting the diagram.

	* **Labels** are often used after a rhombus decision shape, and are used to indicate which route should be taken after the shape, based on the outcome of the decision.

* **Arrows** are used throughout flow diagrams to show the direction of travel around a process. These are particularly important when a diagram begins to grow, and also when decision blocks are used to create loops; a line carrying the interpreter back to an earlier part or forward to a later part of the program could be mistaken for an alternative route at its endpoint, were it not for the arrow-heads indicating direction.

### Functions, Variables and Their Types

Variable naming and types, functions, and pseudo-code are all covered in the [D2 task](#2).

### Interface Design

## Build

koading!

## Testing

Using common techniques for testing, I was able to verify the functionality of the Blackjack program continuously. Based on the findings from my testing, I was able to improve the program and fix bugs.

### Plan

What/how will we test?

### Results

What did we notice?

### Report of Findings

What did we find? (meaning of observations)  
What did we do?

## Evaluative Report

Boring.  
Boring.  
Boring.

# Planning Functions, Variables and Their Types [D2]

## Pseudo-Code

Before writing the application in Python, I wrote some snippets of pseudo-code to further understand some particular parts of the program.

## Data

### Integers

* **`card`** &mdash; An array storing two integers. These are the indices of a card's suit and 

* **`suit`** &mdash; 

* **`value`** &mdash; 

* **`card_new`** &mdash; 

### Booleans

* **`game_over`** &mdash; 

* **`dealer_cont`** &mdash; 

* **`windows`** &mdash; 

### Strings

* **`wins_string`** &mdash; 

* **`wins_split`** &mdash; 

* **`choice`** &mdash; 

* **`action`** &mdash; 

* **`card_name`** &mdash; 

* **`play_again`** &mdash; 

* **`wins`** &mdash; 

### File Objects

* **`wins_file`** &mdash; 

### Importance of Data Types

In order to understand the data that would move around the Blackjack program, I wrote a list of variables that I would use, along with their data types.

<!-- ## Choice of Tools

> * Paradigm choice
> * Language choice
> 	* Too simple a program for objects, really
> 		* Although, `card` class with suit, number vars + `getValue`, similar methods
> * Text editor/IDE -->

# Quality and Readability of Source Code [M1] [D1]

> Using examples of code, explain the difference between good code and bad code (M1). Describe how factors such as commenting, naming conventions for variables and functions, indentation and consistent spacing can improve the readability and comprehensiveness of code (D1) and the importance of good documentation. Include an overall evaluation of your own solution &ndash; listing where it has or hasn't succeeded in meeting these standards.

> Your analysis of good and bad code should take the form of a word-processed document *(lolwut)*, with screen-shots of commented code, possibly from your own recent work. You may also want to include samples of flow-charts and other forms of documentation.  

# Flow and Something [D2]

In order to show the process of execution of the program, I created a flow diagram, shown below. The labelled parts of the diagram are described below.

1. A message being outputted to the user.
2. A decision being made based on user input.
3. A decision being made based on the value of a stored variable.
4. A decision being made based on user input, potentially causing the program to loop.
5. The end of the program being reached, resulting in it quitting.

<div class="i">
	<img src="/btec/img/06.2.1.svg">
	A flow chart showing the steps undertaken by a Blackjack game program. The program was built, and is shown further down the page.
	<div>Image by myself; see <a href="/btec/license">license</a>.</div>
</div>

# Blackjack Python Script

In order to show the use of algorithms, functions, variables, user interaction and more, I build Blackjack digitally, using Python. The code I wrote is shown below, which will work optimally on both Linux/OS X and Windows. When using a terminal emulator that properly supports ANSI escape codes and Unicode characters, such are used. On Windows, escape sequences are disabled and DOS characters are used in place of their Unicode counterparts. You can also use *Right click > "Save link/target as..."* on [this](/btec/file/code/06.3-blackjack-win.py) link to download the script.

<!--[INCLUDE] file/code/06.3-blackjack.py -->
